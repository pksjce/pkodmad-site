webpackJsonp([0x6a275c9139dc],{354:function(e,t){e.exports={data:{markdownRemark:{html:"<p>Ember does a lot of behind-the-scenes work to maintain the relationships and connections between objects in your application. All of Ember's internal objects and those in your application namespace have references stored in another object named Container. This container is referred to under different circumstances during your application's lifecycle to retrieve needed objects. Ember also manages complex dependencies between these objects using the same container.</p>\n<h4>What is Object Management in Ember?</h4>\n<p>Ember creates tons of objects for your definitions. For eg - the singleton router, instances of views that you/handlebars helpers defined and ofcourse your controller, models and templates.<br>\nManagement of these objects in the context of Ember would involve doing the following -  </p>\n<ul>\n<li>Keep track of all the objects defined.</li>\n<li>Retrieving stored objects vs Creating new objects where required vs Retrieve method as is.  </li>\n</ul>\n<h4>When does dependency injection happen in Ember?</h4>\n<p>The answer to this question is - All the time!  </p>\n<ul>\n<li>You can always access your controller from the corresponding view.</li>\n<li>You can always access your router from all the controllers.</li>\n<li>In your route when you say <code>setupController(controller, model)</code>, it may seem magical that <code>controller</code> and <code>model</code> objects are readily available to you. But this is injection and Ember does that for you.  </li>\n</ul>\n<p>Ember does all of these tasks using a class called Container.</p>\n<p>{%highlight javascript%}\nvar container = new Ember.Container();\n{%endhighlight%}</p>\n<p>Your whole application will only have one container that is created by Ember to hold all the component objects and connections between them.Ember accomplishes all the above magic through this container object. </p>\n<h5>Keep track of all the objects defined.</h5>\n<p>When you define an object, say,    </p>\n<p>{%highlight javascript%}\nwindow.App = Ember.Application.create({\nrootElement:\"#mainPage\",\nLOG<em>TRANSITIONS: true,\nLOG</em>BINDINGS:true\n});\n{%endhighlight%}</p>\n<p>Ember registers this 'factory' to the container's registry as <code>application:main</code></p>\n<p>{%highlight javascript%}\ncontainer.register('application:main', Ember.Application.create({\nrootElement:\"#mainPage\",\nLOG<em>TRANSITIONS: true,\nLOG</em>BINDINGS:true\n});)\n{%endhighlight%}\nThe parameters required to register are  </p>\n<ol>\n<li>\n<p>param1 - <code>application:main</code>\nHere the part before <code>:</code> is the <code>type</code> of the function definition.\nThe part after <code>:</code> is the <code>name</code> of the particular definition.</p>\n</li>\n<li>\n<p>param2 - This is the <code>function definition</code> that you provided. This is referred to as the <code>factory</code>  </p>\n</li>\n</ol>\n<h5>Lookup Objects</h5>\n<p>The api <code>container.lookup</code> allows the application to retrieve objects from the container as and when required.  </p>\n<p>{%highlight javascript%}\ncontainer.lookup('application:main');\n{%endhighlight%}</p>\n<p>The lookup basically resolves the string that you have passed to <code>type</code> and <code>name</code> and looks up the factory in the registry. Once the factory has been found, one of the following 3 things has to be decided before returning the object required.  </p>\n<ul>\n<li>Return the factory as it is (in case of a template function)</li>\n<li>Create a new instance of the factory (in case of a view)</li>\n<li>Return an existing instance of the factory (singleton) (in case of the router)</li>\n</ul>\n<p>The choice of the above behaviors is made by defining options for the factory during register. The options are\n<code>{instantiate:true/false}</code> and <code>{singleton:true/false}</code>.  </p>\n<ul>\n<li>instantiate - set this to true if you want a different instance to be created at every lookup.</li>\n<li>singleton - set this to true if you want a singleton instance, that is, the lookup will create the instance only once and store it. Further lookups to this factory would return to you the same instance.<br>\nThe default option for both are false, in which case the container returns the factory object as it is during lookup.</li>\n</ul>\n<p>At this point, it's good to mention that <code>the container object is available in all the objects that are looked up from it</code>. This is a useful thing to know and will be mentioned further down the road.  </p>\n<h4>Dependency injection</h4>\n<p>Injecting dependencies in the Ember contex is to make one object from the registry available in another object of the registry.If this is an instantiated object, then it will be available within the scope of the parent object.  </p>\n<p>The two types of injection are - </p>\n<ol>\n<li>Controlled by the object<br>\nDependency injection inside an object is simply made by lookup of the required object from the container.</li>\n</ol>\n<p>{%highlight javascript%}\nApp.IndexView = Ember.View.extend({\nrouter: function(){\nreturn this.container.lookup('router:main');\n}.property()\n});\n{%endhighlight%}\nSince we know that <code>IndexView</code> will be initialised through the container for your application, <code>this.container</code> will give you the Application container, using which you can register/lookup new definitions/objects.  </p>\n<ol start=\"2\">\n<li>Controlled by outside forces.\nInjecting dependencies from outside an object allows you to maintain a modicum of decoupling between the two objects.</li>\n</ol>\n<p>{%highlight javascript%}\nApp.GoogleAnalytics = Ember.Object.extend({\n/<em>methods to abstract analytics functionality</em>/\n});</p>\n<p>App.register('analytics:google', App.GoogleAnalytics, {singleton:true});\n// Note- App.register and App.inject are facades over container.register/container.inject\nApp.inject('controller', 'analytics', 'analytics:google');\n{%endhighlight%}\nBy doing so, we inject <code>analytics:google</code> as variable <code>analytics</code> in the returned of all factories of type <code>controller</code>.\nWe can also inject objects into a specific <code>type:name</code> factory like</p>\n<p>{%highlight javascript%}\nApp.OtherAnalytics = Ember.Object.extend({\n/<em>methods to abstract analytics functionality</em>/\n})\nApp.register('analytics:other', App.OtherAnalytics, {singleton:true});\nApp.inject('controller:mysplcontroller', 'analytics', 'analytics:other');\n{%endhighlight%}\nThe advantages of relenquishing injection control to an outside authority, allows the <code>controllers</code> from having to keep knowledge of what kind of <code>analytics</code> module they need. Thus, the expectation is that <code>this.analytics.trackPage(data)</code> will work seamlessly across all controllers regardless of the identity of the injected object.</p>",frontmatter:{date:"February 18, 2014",path:"/blog/dependency-management-in-ember",title:"Dependency Management in Ember"}}},pathContext:{}}}});
//# sourceMappingURL=path---blog-dependency-management-in-ember-6b5e334a093c35b0eaa5.js.map