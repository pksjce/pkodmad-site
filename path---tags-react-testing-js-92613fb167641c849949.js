webpackJsonp([0xa11dad15495b],{363:function(e,t){e.exports={pathContext:{nodes:[{excerpt:"During the past 4 months, I have been working on the Flipkart desktop website team. For me it meant finally working on code at scale. If there was anyâ€¦",html:"<p>During the past 4 months, I have been working on the Flipkart desktop website team. For me it meant finally working on code at scale. If there was any place where TDD would be appreciated, it was here, on user facing critical code. The tests were being written on a setup of Karma, Mocha, Sinon and Enzyme. It worked pretty great, but the major peeve for all of us, was that, it was so slow!</p>\n<p>The team had already tried using Jest before, had faced many issues with the automocking and given up. But then Jest made a turnaround and with a great community effort released improved and <a href=\"https://facebook.github.io/jest/blog/2016/10/03/jest-16.html\">new versions</a>. From all the blogposts, we found that Jest's main focus was testing performance and something new called <a href=\"https://facebook.github.io/jest/blog/2016/07/27/jest-14.html\">\"Snapshot testing\"</a>. Also, mainly it promised to be \"Painless JavaScript Testing\". Jest can mostly work for testing in any JavaScript framework or environment. Also, its a known fact that Jest uses itself to test it's codebase.</p>\n<p>This post wants to be an FAQ guide which would have given us extra help during this transition.</p>\n<h2>FAQs</h2>\n<p>The FAQs are categorised by the facet of testing that they cover. These may also apply to any testing in general.</p>\n<h3>Fundamentally speaking</h3>\n<p><strong>Why should we move to <code>Jest</code> when we already have a working setup?</strong></p>\n<p>A move to Jest would mean a somewhat change in paradigm and would involve team effort. We justified the effort with the following reasons</p>\n<ul>\n<li>Jest is way faster than our current setup. It runs test suites in a parallel and the community is focused on improving developer experience through performance.</li>\n<li>I really liked the interactive CLI that comes with it. In <code>watch</code> mode, Jest runs only the tests associated with your code changes. But it allows you to interact with the tests by providing functionality to update snapshots, search for a particular suite, run all tests if you want to.</li>\n<li><a href=\"https://facebook.github.io/jest/docs/getting-started.html\">Great documentation</a></li>\n<li>Snapshot testing for components. It is kind of tailor made for React apps.</li>\n<li>Great defaults meaning \"Zero\" configuration. Running <code>jest</code> alone would be enough to run test files. Mocking is not a marriage of complexity and confusion.</li>\n<li>Existing tests could be easily migrated <a href=\"https://facebook.github.io/jest/docs/migration-guide.html#content\">manually or through automated codemods</a></li>\n</ul>\n<p><strong>What about testing on the browser?</strong></p>\n<p>Yes, the earlier setup opened a chromium browser and tested our components. It was pretty cool actually. But, it was one of the things that made executing tests slow for us. Being priviledged enough to have manual QA, we decided to forego this functionality.</p>\n<p>For more reasoning, you should <a href=\"https://github.com/facebook/jest/issues/139#issuecomment-229277654\">read this</a> by <a href=\"https://github.com/cpojer\">@cpojer</a> on why Facebook doesn't need them.\nAlso, we are open to using <a href=\"https://getstorybook.io/\">React storybook</a> in the future, which I think has potential for browser testing.</p>\n<p><strong>What is Snapshot testing? Will it really help?</strong></p>\n<p>Snapshot testing, is a procedure in which, Jest generates readable snapshots of your component's view. A snapshot is basically a text file with xml, which acts like the source of your view, at that point in your testcase. Different snapshots can be created with different props to your components.</p>\n<p>Snapshots can be saved after simulating events like <code>click</code> and <code>hover</code>. The point would be to save the expected view of your component which is a function of some mock data. If in the future, a developer changes your component, Jest would create a new snapshot of the component and compare it with the saved snapshot. If there is a change in view, it will alert the developer and she will have to tell Jest to save this new snapshot. Since the snapshot is committed to version control, it will show up in a code review and the changes can be approved accordingly.\nWhile we still have reservations of, if its actually feasible to review large changes in the snapshot, I definitely think this enriches the content of a code review.(<strong>Edit</strong> <a href=\"https://github.com/cpojer\">@cpojer</a> said in this <a href=\"https://github.com/kosamari/web.advent.today/pull/27#discussion_r91407888\">comment</a> that snapshots are even more powerful!)</p>\n<h3>Implementation Questions</h3>\n<p><strong>How do I test my React+Redux code?</strong></p>\n<p>We have been following an approach where we test each of the moving parts independently.</p>\n<h2>Components</h2>\n<p>A React component is a view only component, with some event handling and some local state. It is <code>connect</code>ed to the Redux store for state and actions.\nWe test the base component, which is free of Redux. For a component like,</p>\n<p><strong>my-component.js</strong></p>\n<pre><code class=\"language-javascript\">import React, {Component} from 'react';\nimport {connect} from 'react-redux';\n\nexport class MyComponent extends Component {\n    constructor () {\n    super();\n    this.state = {\n        localProp: 'Default'\n    };\n    }\n    handleClick = () => {\n    this.setState({\n        localProp: 'After click'\n    });\n    }\n    render () {\n    return (&#x3C;div>\n        &#x3C;div>{this.props.reduxProp}&#x3C;/div>\n        &#x3C;div>{this.state.localProp}&#x3C;/div>\n        &#x3C;div onClick={this.handleClick}>Click me&#x3C;/div>\n    &#x3C;/div>);\n    }\n}\n\nexport default connect(reduxState => ({reduxProp: reduxState.prop}) )(MyComponent)\n</code></pre>\n<p><strong>my-component.test.js</strong></p>\n<pre><code class=\"language-javascript\">// needed for jsx\nimport React from 'react';\n// import the named export\nimport {MyComponent} from './my-component';\n// enzyme has rendering utils\nimport {shallow} from 'enzyme';\n// needed to create snapshot\nimport {shallowToJson} from 'enzyme-to-json';\n\ndescribe('&#x3C;MyComponent />', () => {\n    let component;\n    // create an instance of MyComponent before each test\n    beforeEach(() => {\n        component = shallow(&#x3C;MyComponent reduxProp=\"A test prop\" />);\n    });\n    // test rendering expectations\n    it('should render well', () => {\n        // DOM test\n        expect(component.contains(&#x3C;div>A test prop&#x3C;/div>)).toBe(true);\n        expect(component.contains(&#x3C;div>Default&#x3C;/div>)).toBe(true);\n        // Match snapshots (creates the first time)\n        expect(shallowToJson(component)).toMatchSnapshot();\n    });\n    // test the action\n    it('should change text after click', () => {\n        //find particular DOM and simulate click\n        component.childAt(2).simulate('click');\n        test expectation after click is done\n        expect(component.text().indexOf('After click') > -1).toBe(true);\n        // match snapshot because view changed.\n        expect(shallowToJson(component)).toMatchSnapshot();\n    });\n});\n</code></pre>\n<h2>Reducers</h2>\n<p>Reducers, being pure functions, are ridiculously easy to test. The redux docs <a href=\"http://redux.js.org/docs/recipes/WritingTests.html#reducers\">shows how to do this</a>.</p>\n<h2>Actions</h2>\n<p>We used the <a href=\"http://redux.js.org/docs/recipes/WritingTests.html#async-action-creators\">recommended technique</a>, but instead of using <code>nock</code> we decided to mock the <code>fetch</code> api with Jest's easy mocking system.</p>\n<p><strong>asyncUtil.js</strong></p>\n<pre><code class=\"language-javascript\">import configureMockStore from 'redux-mock-store';\nimport thunk from 'redux-thunk';\nimport fetchMock from 'fetch-mock';\n\nexport const runsynctest = ({testName, expectedAction, fn, params}) => {\n    it(testName, () => {\n        expect(fn.call(null, ...params)).toEqual(expectedAction);\n    });\n};\nexport const runasynctest = ({testName, expectedActions, fn, params}) => {\n    const middlewares = [ thunk ];\n    const mockStore = configureMockStore(middlewares);\n    const store = mockStore();\n    fetchMock.mock('*', params); // This can be customised\n    it(testName, () => {\n    return store\n        .dispatch(fn.call(null, ...params))\n        .then(args => {\n            expect(store.getActions()).toEqual(expectedActions);\n        });\n    });\n};\n</code></pre>\n<p><strong>my-action.test.js</strong></p>\n<pre><code class=\"language-javascript\">import { runasynctest, runsynctest } from './actionsUtil';\n// fetchVal is your typical fetch action which returns a promise\nimport { fetchVal } from '../my-actions';\nimport * as types from 'constants/my-constants';\n\ndescribe('async-actions', () => {\n    runasynctest(\n    {\n        testName: 'should simulate fetch action',\n        expectedActions: [\n        { type: types.GET__REQUEST },\n        {\n            type: types.GET__SUCCESS,\n            pids: [1, 2]\n        }\n        ],\n        fn: fetchVal,\n        params: [[1, 2]]\n    });\n});\n</code></pre>\n<h2>Components with Actions</h2>\n<p>If in the above example for <code>MyComponent</code>'s testing, the <code>handleClick</code> were to send actions with redux like</p>\n<p><strong>my-component.js</strong></p>\n<pre><code class=\"language-javascript\">...\n\nhandleClick = event => {\n    this.props.fetchValAction(event);\n}\n\n...\n</code></pre>\n<p><strong>my-component.test.js</strong></p>\n<pre><code class=\"language-javascript\">describe('&#x3C;MyComponent />', () => {\n    it('should call fetchVal action', () => {\n    const mockFetchVal = jest.mock();\n    const component = mount(&#x3C;MyComponent fetchValAction={mockFetchVal}/>);\n    component.childAt(2).simulate('click');\n    expect(mockFetchVal).toHaveBeenCalled();\n    })\n})\n</code></pre>\n<p>tldr; Various solutions can be adopted. Choose whichever suits your environment.</p>\n<p><strong>How do I test asynchronous functions?</strong></p>\n<p>The Jest docs has a <a href=\"https://facebook.github.io/jest/docs/tutorial-async.html#content\">tutorial on asynchronous testing</a>. Converting them to <code>Promises</code> works too.</p>\n<p><strong>How to simulate window events?</strong></p>\n<p>We used <a href=\"https://github.com/tmpvar/jsdom\">jsdom</a> to get a DOM that works with Node.js.\nWe set it up for the project at Jest's <a href=\"https://facebook.github.io/jest/docs/configuration.html#setupfiles-array\"><code>setupFile</code></a>. </p>\n<p><strong>setupFile.js</strong></p>\n<pre><code class=\"language-javascript\">const jsdom = require('jsdom');\n\nconst documentHTML = '&#x3C;!doctype html>&#x3C;html>&#x3C;body>&#x3C;div id=\"root\">&#x3C;/div>&#x3C;/body>&#x3C;/html>';\nglobal.document = jsdom.jsdom(documentHTML);\nglobal.window = document.parentWindow;\nglobal.window.resizeTo = (width, height) => {\n    global.window.innerWidth = width || global.window.innerWidth;\n    global.window.innerHeight = width || global.window.innerHeight;\n    global.window.dispatchEvent(new Event('resize'));\n};\nglobal.Promise = require.requireActual('promise');\n</code></pre>\n<p>Now we can simulate resize by the mock method above. So we have tests like below.</p>\n<p><strong>example</strong></p>\n<pre><code class=\"language-javascript\">/*\n  The test below checks if snapshots were the same before and after resizes.\n  You can also test for other window events like scroll in this manner.\n*/\nit('should resize properly', () => {\n  const props = { highlights: true };\n  const component = mount(&#x3C;MyComponent {...props} />, {attachTo: document.getElementById('root')});\n  global.window.resizeTo(1025);\n  expect(mountToJson(component)).toMatchSnapshot();\n  global.window.resizeTo(1020);\n  expect(mountToJson(component)).toMatchSnapshot();\n});\n</code></pre>\n<p><strong>I can't get PostCSS to work!</strong></p>\n<p>This was one area where Jest fell short of expectations. <code>karma</code> allows you directly put in <code>webpack</code> transformations onto the configuration. <code>Jest</code> has <a href=\"https://facebook.github.io/jest/docs/tutorial-webpack.html#content\">equivalent configuration</a> which is mapped to <code>webpack</code> config. But we found it to be adequate for our needs except that we could not get PostCSS plugins to work. Babel preprocessing is done out of the box using <a href=\"http://facebook.github.io/jest/docs/getting-started.html#babel-integration\"><code>babel-jest</code></a> which comes bundled with Jest in the latest version. Jest can support <a href=\"https://facebook.github.io/jest/docs/configuration.html#transform-object-string-string\">some preprocessors</a>, but somehow cannot support PostCSS as it has asynchronous plugins.\nSo we had to use this proxy called <a href=\"https://github.com/keyanzhang/identity-obj-proxy\">identity-obj-proxy</a> to proxy our styles with the given className.</p>\n<p>An alternative would be to try <a href=\"https://github.com/kosamari/web.advent.today/pull/27#discussion_r91408412\">this advice</a> to preprocess all the css for easy consumption.</p>\n<p>For example for JSX,</p>\n<p><code>&#x3C;div className={styles['button-class']}>Click&#x3C;/div></code></p>\n<p>the below snapshot is generated,</p>\n<p><code>&#x3C;div className='button-class'>Click&#x3C;/div></code></p>\n<p>It does not allow you to test for true styles, only classNames. But, its a tradeoff we have made.</p>\n<p><strong>Can I calculate coverage?</strong></p>\n<p>I'm glad you asked the question! Coverage stats are inbuilt within Jest. No configuration is required. <code>jest --coverage</code> does it.\nThe downside is that it considerably slows down your test runs. Hence we don't keep it on during development. There are also really cool features like coverage thresholds. You can learn this by watching this excellent video on <a href=\"https://egghead.io/lessons/javascript-track-project-code-coverage-with-jest\">Egghead.io by @kentcdodds</a>.</p>\n<h2>Conclusion</h2>\n<p>Its been a couple of weeks since we started using <code>Jest</code>. Code Coverage is slowly growing within the team. However we have configured our PR builds to fail if existing tests fail, that includes snapshots. In the future, we plan to have coverage thresholds too!</p>\n<p>PS - Thanks to <a href=\"https://twitter.com/kosamari\">@kosamari</a> for the encouragement, <a href=\"https://twitter.com/saha_varsha\">@saha_varsha</a> for actually battle testing the above scripts, <a href=\"https://twitter.com/cpojer\">@cpojer</a> for the review and active involvement and <a href=\"https://twitter.com/rahulcs\">@rahulcs</a> for the patient review!</p>",id:"/Users/pkodmad/Workspace/pkodmad-site/posts/2016-12-08-notes-on-jest.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2016-12-08",path:"/blog/notes-on-jest",title:"Notes on Jest",tags:["react","testing","js"]}},{excerpt:"During the past 4 months, I have been working on the Flipkart desktop website team. For me it meant finally working on code at scale. If there was anyâ€¦",html:"<p>During the past 4 months, I have been working on the Flipkart desktop website team. For me it meant finally working on code at scale. If there was any place where TDD would be appreciated, it was here, on user facing critical code. The tests were being written on a setup of Karma, Mocha, Sinon and Enzyme. It worked pretty great, but the major peeve for all of us, was that, it was so slow!</p>\n<p>The team had already tried using Jest before, had faced many issues with the automocking and given up. But then Jest made a turnaround and with a great community effort released improved and <a href=\"https://facebook.github.io/jest/blog/2016/10/03/jest-16.html\">new versions</a>. From all the blogposts, we found that Jest's main focus was testing performance and something new called <a href=\"https://facebook.github.io/jest/blog/2016/07/27/jest-14.html\">\"Snapshot testing\"</a>. Also, mainly it promised to be \"Painless JavaScript Testing\". Jest can mostly work for testing in any JavaScript framework or environment. Also, its a known fact that Jest uses itself to test it's codebase.</p>\n<p>This post wants to be an FAQ guide which would have given us extra help during this transition.</p>\n<h2>FAQs</h2>\n<p>The FAQs are categorised by the facet of testing that they cover. These may also apply to any testing in general.</p>\n<h3>Fundamentally speaking</h3>\n<p><strong>Why should we move to <code>Jest</code> when we already have a working setup?</strong></p>\n<p>A move to Jest would mean a somewhat change in paradigm and would involve team effort. We justified the effort with the following reasons</p>\n<ul>\n<li>Jest is way faster than our current setup. It runs test suites in a parallel and the community is focused on improving developer experience through performance.</li>\n<li>I really liked the interactive CLI that comes with it. In <code>watch</code> mode, Jest runs only the tests associated with your code changes. But it allows you to interact with the tests by providing functionality to update snapshots, search for a particular suite, run all tests if you want to.</li>\n<li><a href=\"https://facebook.github.io/jest/docs/getting-started.html\">Great documentation</a></li>\n<li>Snapshot testing for components. It is kind of tailor made for React apps.</li>\n<li>Great defaults meaning \"Zero\" configuration. Running <code>jest</code> alone would be enough to run test files. Mocking is not a marriage of complexity and confusion.</li>\n<li>Existing tests could be easily migrated <a href=\"https://facebook.github.io/jest/docs/migration-guide.html#content\">manually or through automated codemods</a></li>\n</ul>\n<p><strong>What about testing on the browser?</strong></p>\n<p>Yes, the earlier setup opened a chromium browser and tested our components. It was pretty cool actually. But, it was one of the things that made executing tests slow for us. Being priviledged enough to have manual QA, we decided to forego this functionality.</p>\n<p>For more reasoning, you should <a href=\"https://github.com/facebook/jest/issues/139#issuecomment-229277654\">read this</a> by <a href=\"https://github.com/cpojer\">@cpojer</a> on why Facebook doesn't need them.\nAlso, we are open to using <a href=\"https://getstorybook.io/\">React storybook</a> in the future, which I think has potential for browser testing.</p>\n<p><strong>What is Snapshot testing? Will it really help?</strong></p>\n<p>Snapshot testing, is a procedure in which, Jest generates readable snapshots of your component's view. A snapshot is basically a text file with xml, which acts like the source of your view, at that point in your testcase. Different snapshots can be created with different props to your components.</p>\n<p>Snapshots can be saved after simulating events like <code>click</code> and <code>hover</code>. The point would be to save the expected view of your component which is a function of some mock data. If in the future, a developer changes your component, Jest would create a new snapshot of the component and compare it with the saved snapshot. If there is a change in view, it will alert the developer and she will have to tell Jest to save this new snapshot. Since the snapshot is committed to version control, it will show up in a code review and the changes can be approved accordingly.\nWhile we still have reservations of, if its actually feasible to review large changes in the snapshot, I definitely think this enriches the content of a code review.(<strong>Edit</strong> <a href=\"https://github.com/cpojer\">@cpojer</a> said in this <a href=\"https://github.com/kosamari/web.advent.today/pull/27#discussion_r91407888\">comment</a> that snapshots are even more powerful!)</p>\n<h3>Implementation Questions</h3>\n<p><strong>How do I test my React+Redux code?</strong></p>\n<p>We have been following an approach where we test each of the moving parts independently.</p>\n<h2>Components</h2>\n<p>A React component is a view only component, with some event handling and some local state. It is <code>connect</code>ed to the Redux store for state and actions.\nWe test the base component, which is free of Redux. For a component like,</p>\n<p><strong>my-component.js</strong></p>\n<pre><code class=\"language-javascript\">import React, {Component} from 'react';\nimport {connect} from 'react-redux';\n\nexport class MyComponent extends Component {\n    constructor () {\n    super();\n    this.state = {\n        localProp: 'Default'\n    };\n    }\n    handleClick = () => {\n    this.setState({\n        localProp: 'After click'\n    });\n    }\n    render () {\n    return (&#x3C;div>\n        &#x3C;div>{this.props.reduxProp}&#x3C;/div>\n        &#x3C;div>{this.state.localProp}&#x3C;/div>\n        &#x3C;div onClick={this.handleClick}>Click me&#x3C;/div>\n    &#x3C;/div>);\n    }\n}\n\nexport default connect(reduxState => ({reduxProp: reduxState.prop}) )(MyComponent)\n</code></pre>\n<p><strong>my-component.test.js</strong></p>\n<pre><code class=\"language-javascript\">// needed for jsx\nimport React from 'react';\n// import the named export\nimport {MyComponent} from './my-component';\n// enzyme has rendering utils\nimport {shallow} from 'enzyme';\n// needed to create snapshot\nimport {shallowToJson} from 'enzyme-to-json';\n\ndescribe('&#x3C;MyComponent />', () => {\n    let component;\n    // create an instance of MyComponent before each test\n    beforeEach(() => {\n        component = shallow(&#x3C;MyComponent reduxProp=\"A test prop\" />);\n    });\n    // test rendering expectations\n    it('should render well', () => {\n        // DOM test\n        expect(component.contains(&#x3C;div>A test prop&#x3C;/div>)).toBe(true);\n        expect(component.contains(&#x3C;div>Default&#x3C;/div>)).toBe(true);\n        // Match snapshots (creates the first time)\n        expect(shallowToJson(component)).toMatchSnapshot();\n    });\n    // test the action\n    it('should change text after click', () => {\n        //find particular DOM and simulate click\n        component.childAt(2).simulate('click');\n        test expectation after click is done\n        expect(component.text().indexOf('After click') > -1).toBe(true);\n        // match snapshot because view changed.\n        expect(shallowToJson(component)).toMatchSnapshot();\n    });\n});\n</code></pre>\n<h2>Reducers</h2>\n<p>Reducers, being pure functions, are ridiculously easy to test. The redux docs <a href=\"http://redux.js.org/docs/recipes/WritingTests.html#reducers\">shows how to do this</a>.</p>\n<h2>Actions</h2>\n<p>We used the <a href=\"http://redux.js.org/docs/recipes/WritingTests.html#async-action-creators\">recommended technique</a>, but instead of using <code>nock</code> we decided to mock the <code>fetch</code> api with Jest's easy mocking system.</p>\n<p><strong>asyncUtil.js</strong></p>\n<pre><code class=\"language-javascript\">import configureMockStore from 'redux-mock-store';\nimport thunk from 'redux-thunk';\nimport fetchMock from 'fetch-mock';\n\nexport const runsynctest = ({testName, expectedAction, fn, params}) => {\n    it(testName, () => {\n        expect(fn.call(null, ...params)).toEqual(expectedAction);\n    });\n};\nexport const runasynctest = ({testName, expectedActions, fn, params}) => {\n    const middlewares = [ thunk ];\n    const mockStore = configureMockStore(middlewares);\n    const store = mockStore();\n    fetchMock.mock('*', params); // This can be customised\n    it(testName, () => {\n    return store\n        .dispatch(fn.call(null, ...params))\n        .then(args => {\n            expect(store.getActions()).toEqual(expectedActions);\n        });\n    });\n};\n</code></pre>\n<p><strong>my-action.test.js</strong></p>\n<pre><code class=\"language-javascript\">import { runasynctest, runsynctest } from './actionsUtil';\n// fetchVal is your typical fetch action which returns a promise\nimport { fetchVal } from '../my-actions';\nimport * as types from 'constants/my-constants';\n\ndescribe('async-actions', () => {\n    runasynctest(\n    {\n        testName: 'should simulate fetch action',\n        expectedActions: [\n        { type: types.GET__REQUEST },\n        {\n            type: types.GET__SUCCESS,\n            pids: [1, 2]\n        }\n        ],\n        fn: fetchVal,\n        params: [[1, 2]]\n    });\n});\n</code></pre>\n<h2>Components with Actions</h2>\n<p>If in the above example for <code>MyComponent</code>'s testing, the <code>handleClick</code> were to send actions with redux like</p>\n<p><strong>my-component.js</strong></p>\n<pre><code class=\"language-javascript\">...\n\nhandleClick = event => {\n    this.props.fetchValAction(event);\n}\n\n...\n</code></pre>\n<p><strong>my-component.test.js</strong></p>\n<pre><code class=\"language-javascript\">describe('&#x3C;MyComponent />', () => {\n    it('should call fetchVal action', () => {\n    const mockFetchVal = jest.mock();\n    const component = mount(&#x3C;MyComponent fetchValAction={mockFetchVal}/>);\n    component.childAt(2).simulate('click');\n    expect(mockFetchVal).toHaveBeenCalled();\n    })\n})\n</code></pre>\n<p>tldr; Various solutions can be adopted. Choose whichever suits your environment.</p>\n<p><strong>How do I test asynchronous functions?</strong></p>\n<p>The Jest docs has a <a href=\"https://facebook.github.io/jest/docs/tutorial-async.html#content\">tutorial on asynchronous testing</a>. Converting them to <code>Promises</code> works too.</p>\n<p><strong>How to simulate window events?</strong></p>\n<p>We used <a href=\"https://github.com/tmpvar/jsdom\">jsdom</a> to get a DOM that works with Node.js.\nWe set it up for the project at Jest's <a href=\"https://facebook.github.io/jest/docs/configuration.html#setupfiles-array\"><code>setupFile</code></a>. </p>\n<p><strong>setupFile.js</strong></p>\n<pre><code class=\"language-javascript\">const jsdom = require('jsdom');\n\nconst documentHTML = '&#x3C;!doctype html>&#x3C;html>&#x3C;body>&#x3C;div id=\"root\">&#x3C;/div>&#x3C;/body>&#x3C;/html>';\nglobal.document = jsdom.jsdom(documentHTML);\nglobal.window = document.parentWindow;\nglobal.window.resizeTo = (width, height) => {\n    global.window.innerWidth = width || global.window.innerWidth;\n    global.window.innerHeight = width || global.window.innerHeight;\n    global.window.dispatchEvent(new Event('resize'));\n};\nglobal.Promise = require.requireActual('promise');\n</code></pre>\n<p>Now we can simulate resize by the mock method above. So we have tests like below.</p>\n<p><strong>example</strong></p>\n<pre><code class=\"language-javascript\">/*\n  The test below checks if snapshots were the same before and after resizes.\n  You can also test for other window events like scroll in this manner.\n*/\nit('should resize properly', () => {\n  const props = { highlights: true };\n  const component = mount(&#x3C;MyComponent {...props} />, {attachTo: document.getElementById('root')});\n  global.window.resizeTo(1025);\n  expect(mountToJson(component)).toMatchSnapshot();\n  global.window.resizeTo(1020);\n  expect(mountToJson(component)).toMatchSnapshot();\n});\n</code></pre>\n<p><strong>I can't get PostCSS to work!</strong></p>\n<p>This was one area where Jest fell short of expectations. <code>karma</code> allows you directly put in <code>webpack</code> transformations onto the configuration. <code>Jest</code> has <a href=\"https://facebook.github.io/jest/docs/tutorial-webpack.html#content\">equivalent configuration</a> which is mapped to <code>webpack</code> config. But we found it to be adequate for our needs except that we could not get PostCSS plugins to work. Babel preprocessing is done out of the box using <a href=\"http://facebook.github.io/jest/docs/getting-started.html#babel-integration\"><code>babel-jest</code></a> which comes bundled with Jest in the latest version. Jest can support <a href=\"https://facebook.github.io/jest/docs/configuration.html#transform-object-string-string\">some preprocessors</a>, but somehow cannot support PostCSS as it has asynchronous plugins.\nSo we had to use this proxy called <a href=\"https://github.com/keyanzhang/identity-obj-proxy\">identity-obj-proxy</a> to proxy our styles with the given className.</p>\n<p>An alternative would be to try <a href=\"https://github.com/kosamari/web.advent.today/pull/27#discussion_r91408412\">this advice</a> to preprocess all the css for easy consumption.</p>\n<p>For example for JSX,</p>\n<p><code>&#x3C;div className={styles['button-class']}>Click&#x3C;/div></code></p>\n<p>the below snapshot is generated,</p>\n<p><code>&#x3C;div className='button-class'>Click&#x3C;/div></code></p>\n<p>It does not allow you to test for true styles, only classNames. But, its a tradeoff we have made.</p>\n<p><strong>Can I calculate coverage?</strong></p>\n<p>I'm glad you asked the question! Coverage stats are inbuilt within Jest. No configuration is required. <code>jest --coverage</code> does it.\nThe downside is that it considerably slows down your test runs. Hence we don't keep it on during development. There are also really cool features like coverage thresholds. You can learn this by watching this excellent video on <a href=\"https://egghead.io/lessons/javascript-track-project-code-coverage-with-jest\">Egghead.io by @kentcdodds</a>.</p>\n<h2>Conclusion</h2>\n<p>Its been a couple of weeks since we started using <code>Jest</code>. Code Coverage is slowly growing within the team. However we have configured our PR builds to fail if existing tests fail, that includes snapshots. In the future, we plan to have coverage thresholds too!</p>\n<p>PS - Thanks to <a href=\"https://twitter.com/kosamari\">@kosamari</a> for the encouragement, <a href=\"https://twitter.com/saha_varsha\">@saha_varsha</a> for actually battle testing the above scripts, <a href=\"https://twitter.com/cpojer\">@cpojer</a> for the review and active involvement and <a href=\"https://twitter.com/rahulcs\">@rahulcs</a> for the patient review!</p>",id:"/Users/pkodmad/Workspace/pkodmad-site/posts/2016-12-08-notes-on-jest.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2016-12-08",path:"/blog/notes-on-jest",title:"Notes on Jest",tags:["react","testing","js"]}},{excerpt:"During the past 4 months, I have been working on the Flipkart desktop website team. For me it meant finally working on code at scale. If there was anyâ€¦",html:"<p>During the past 4 months, I have been working on the Flipkart desktop website team. For me it meant finally working on code at scale. If there was any place where TDD would be appreciated, it was here, on user facing critical code. The tests were being written on a setup of Karma, Mocha, Sinon and Enzyme. It worked pretty great, but the major peeve for all of us, was that, it was so slow!</p>\n<p>The team had already tried using Jest before, had faced many issues with the automocking and given up. But then Jest made a turnaround and with a great community effort released improved and <a href=\"https://facebook.github.io/jest/blog/2016/10/03/jest-16.html\">new versions</a>. From all the blogposts, we found that Jest's main focus was testing performance and something new called <a href=\"https://facebook.github.io/jest/blog/2016/07/27/jest-14.html\">\"Snapshot testing\"</a>. Also, mainly it promised to be \"Painless JavaScript Testing\". Jest can mostly work for testing in any JavaScript framework or environment. Also, its a known fact that Jest uses itself to test it's codebase.</p>\n<p>This post wants to be an FAQ guide which would have given us extra help during this transition.</p>\n<h2>FAQs</h2>\n<p>The FAQs are categorised by the facet of testing that they cover. These may also apply to any testing in general.</p>\n<h3>Fundamentally speaking</h3>\n<p><strong>Why should we move to <code>Jest</code> when we already have a working setup?</strong></p>\n<p>A move to Jest would mean a somewhat change in paradigm and would involve team effort. We justified the effort with the following reasons</p>\n<ul>\n<li>Jest is way faster than our current setup. It runs test suites in a parallel and the community is focused on improving developer experience through performance.</li>\n<li>I really liked the interactive CLI that comes with it. In <code>watch</code> mode, Jest runs only the tests associated with your code changes. But it allows you to interact with the tests by providing functionality to update snapshots, search for a particular suite, run all tests if you want to.</li>\n<li><a href=\"https://facebook.github.io/jest/docs/getting-started.html\">Great documentation</a></li>\n<li>Snapshot testing for components. It is kind of tailor made for React apps.</li>\n<li>Great defaults meaning \"Zero\" configuration. Running <code>jest</code> alone would be enough to run test files. Mocking is not a marriage of complexity and confusion.</li>\n<li>Existing tests could be easily migrated <a href=\"https://facebook.github.io/jest/docs/migration-guide.html#content\">manually or through automated codemods</a></li>\n</ul>\n<p><strong>What about testing on the browser?</strong></p>\n<p>Yes, the earlier setup opened a chromium browser and tested our components. It was pretty cool actually. But, it was one of the things that made executing tests slow for us. Being priviledged enough to have manual QA, we decided to forego this functionality.</p>\n<p>For more reasoning, you should <a href=\"https://github.com/facebook/jest/issues/139#issuecomment-229277654\">read this</a> by <a href=\"https://github.com/cpojer\">@cpojer</a> on why Facebook doesn't need them.\nAlso, we are open to using <a href=\"https://getstorybook.io/\">React storybook</a> in the future, which I think has potential for browser testing.</p>\n<p><strong>What is Snapshot testing? Will it really help?</strong></p>\n<p>Snapshot testing, is a procedure in which, Jest generates readable snapshots of your component's view. A snapshot is basically a text file with xml, which acts like the source of your view, at that point in your testcase. Different snapshots can be created with different props to your components.</p>\n<p>Snapshots can be saved after simulating events like <code>click</code> and <code>hover</code>. The point would be to save the expected view of your component which is a function of some mock data. If in the future, a developer changes your component, Jest would create a new snapshot of the component and compare it with the saved snapshot. If there is a change in view, it will alert the developer and she will have to tell Jest to save this new snapshot. Since the snapshot is committed to version control, it will show up in a code review and the changes can be approved accordingly.\nWhile we still have reservations of, if its actually feasible to review large changes in the snapshot, I definitely think this enriches the content of a code review.(<strong>Edit</strong> <a href=\"https://github.com/cpojer\">@cpojer</a> said in this <a href=\"https://github.com/kosamari/web.advent.today/pull/27#discussion_r91407888\">comment</a> that snapshots are even more powerful!)</p>\n<h3>Implementation Questions</h3>\n<p><strong>How do I test my React+Redux code?</strong></p>\n<p>We have been following an approach where we test each of the moving parts independently.</p>\n<h2>Components</h2>\n<p>A React component is a view only component, with some event handling and some local state. It is <code>connect</code>ed to the Redux store for state and actions.\nWe test the base component, which is free of Redux. For a component like,</p>\n<p><strong>my-component.js</strong></p>\n<pre><code class=\"language-javascript\">import React, {Component} from 'react';\nimport {connect} from 'react-redux';\n\nexport class MyComponent extends Component {\n    constructor () {\n    super();\n    this.state = {\n        localProp: 'Default'\n    };\n    }\n    handleClick = () => {\n    this.setState({\n        localProp: 'After click'\n    });\n    }\n    render () {\n    return (&#x3C;div>\n        &#x3C;div>{this.props.reduxProp}&#x3C;/div>\n        &#x3C;div>{this.state.localProp}&#x3C;/div>\n        &#x3C;div onClick={this.handleClick}>Click me&#x3C;/div>\n    &#x3C;/div>);\n    }\n}\n\nexport default connect(reduxState => ({reduxProp: reduxState.prop}) )(MyComponent)\n</code></pre>\n<p><strong>my-component.test.js</strong></p>\n<pre><code class=\"language-javascript\">// needed for jsx\nimport React from 'react';\n// import the named export\nimport {MyComponent} from './my-component';\n// enzyme has rendering utils\nimport {shallow} from 'enzyme';\n// needed to create snapshot\nimport {shallowToJson} from 'enzyme-to-json';\n\ndescribe('&#x3C;MyComponent />', () => {\n    let component;\n    // create an instance of MyComponent before each test\n    beforeEach(() => {\n        component = shallow(&#x3C;MyComponent reduxProp=\"A test prop\" />);\n    });\n    // test rendering expectations\n    it('should render well', () => {\n        // DOM test\n        expect(component.contains(&#x3C;div>A test prop&#x3C;/div>)).toBe(true);\n        expect(component.contains(&#x3C;div>Default&#x3C;/div>)).toBe(true);\n        // Match snapshots (creates the first time)\n        expect(shallowToJson(component)).toMatchSnapshot();\n    });\n    // test the action\n    it('should change text after click', () => {\n        //find particular DOM and simulate click\n        component.childAt(2).simulate('click');\n        test expectation after click is done\n        expect(component.text().indexOf('After click') > -1).toBe(true);\n        // match snapshot because view changed.\n        expect(shallowToJson(component)).toMatchSnapshot();\n    });\n});\n</code></pre>\n<h2>Reducers</h2>\n<p>Reducers, being pure functions, are ridiculously easy to test. The redux docs <a href=\"http://redux.js.org/docs/recipes/WritingTests.html#reducers\">shows how to do this</a>.</p>\n<h2>Actions</h2>\n<p>We used the <a href=\"http://redux.js.org/docs/recipes/WritingTests.html#async-action-creators\">recommended technique</a>, but instead of using <code>nock</code> we decided to mock the <code>fetch</code> api with Jest's easy mocking system.</p>\n<p><strong>asyncUtil.js</strong></p>\n<pre><code class=\"language-javascript\">import configureMockStore from 'redux-mock-store';\nimport thunk from 'redux-thunk';\nimport fetchMock from 'fetch-mock';\n\nexport const runsynctest = ({testName, expectedAction, fn, params}) => {\n    it(testName, () => {\n        expect(fn.call(null, ...params)).toEqual(expectedAction);\n    });\n};\nexport const runasynctest = ({testName, expectedActions, fn, params}) => {\n    const middlewares = [ thunk ];\n    const mockStore = configureMockStore(middlewares);\n    const store = mockStore();\n    fetchMock.mock('*', params); // This can be customised\n    it(testName, () => {\n    return store\n        .dispatch(fn.call(null, ...params))\n        .then(args => {\n            expect(store.getActions()).toEqual(expectedActions);\n        });\n    });\n};\n</code></pre>\n<p><strong>my-action.test.js</strong></p>\n<pre><code class=\"language-javascript\">import { runasynctest, runsynctest } from './actionsUtil';\n// fetchVal is your typical fetch action which returns a promise\nimport { fetchVal } from '../my-actions';\nimport * as types from 'constants/my-constants';\n\ndescribe('async-actions', () => {\n    runasynctest(\n    {\n        testName: 'should simulate fetch action',\n        expectedActions: [\n        { type: types.GET__REQUEST },\n        {\n            type: types.GET__SUCCESS,\n            pids: [1, 2]\n        }\n        ],\n        fn: fetchVal,\n        params: [[1, 2]]\n    });\n});\n</code></pre>\n<h2>Components with Actions</h2>\n<p>If in the above example for <code>MyComponent</code>'s testing, the <code>handleClick</code> were to send actions with redux like</p>\n<p><strong>my-component.js</strong></p>\n<pre><code class=\"language-javascript\">...\n\nhandleClick = event => {\n    this.props.fetchValAction(event);\n}\n\n...\n</code></pre>\n<p><strong>my-component.test.js</strong></p>\n<pre><code class=\"language-javascript\">describe('&#x3C;MyComponent />', () => {\n    it('should call fetchVal action', () => {\n    const mockFetchVal = jest.mock();\n    const component = mount(&#x3C;MyComponent fetchValAction={mockFetchVal}/>);\n    component.childAt(2).simulate('click');\n    expect(mockFetchVal).toHaveBeenCalled();\n    })\n})\n</code></pre>\n<p>tldr; Various solutions can be adopted. Choose whichever suits your environment.</p>\n<p><strong>How do I test asynchronous functions?</strong></p>\n<p>The Jest docs has a <a href=\"https://facebook.github.io/jest/docs/tutorial-async.html#content\">tutorial on asynchronous testing</a>. Converting them to <code>Promises</code> works too.</p>\n<p><strong>How to simulate window events?</strong></p>\n<p>We used <a href=\"https://github.com/tmpvar/jsdom\">jsdom</a> to get a DOM that works with Node.js.\nWe set it up for the project at Jest's <a href=\"https://facebook.github.io/jest/docs/configuration.html#setupfiles-array\"><code>setupFile</code></a>. </p>\n<p><strong>setupFile.js</strong></p>\n<pre><code class=\"language-javascript\">const jsdom = require('jsdom');\n\nconst documentHTML = '&#x3C;!doctype html>&#x3C;html>&#x3C;body>&#x3C;div id=\"root\">&#x3C;/div>&#x3C;/body>&#x3C;/html>';\nglobal.document = jsdom.jsdom(documentHTML);\nglobal.window = document.parentWindow;\nglobal.window.resizeTo = (width, height) => {\n    global.window.innerWidth = width || global.window.innerWidth;\n    global.window.innerHeight = width || global.window.innerHeight;\n    global.window.dispatchEvent(new Event('resize'));\n};\nglobal.Promise = require.requireActual('promise');\n</code></pre>\n<p>Now we can simulate resize by the mock method above. So we have tests like below.</p>\n<p><strong>example</strong></p>\n<pre><code class=\"language-javascript\">/*\n  The test below checks if snapshots were the same before and after resizes.\n  You can also test for other window events like scroll in this manner.\n*/\nit('should resize properly', () => {\n  const props = { highlights: true };\n  const component = mount(&#x3C;MyComponent {...props} />, {attachTo: document.getElementById('root')});\n  global.window.resizeTo(1025);\n  expect(mountToJson(component)).toMatchSnapshot();\n  global.window.resizeTo(1020);\n  expect(mountToJson(component)).toMatchSnapshot();\n});\n</code></pre>\n<p><strong>I can't get PostCSS to work!</strong></p>\n<p>This was one area where Jest fell short of expectations. <code>karma</code> allows you directly put in <code>webpack</code> transformations onto the configuration. <code>Jest</code> has <a href=\"https://facebook.github.io/jest/docs/tutorial-webpack.html#content\">equivalent configuration</a> which is mapped to <code>webpack</code> config. But we found it to be adequate for our needs except that we could not get PostCSS plugins to work. Babel preprocessing is done out of the box using <a href=\"http://facebook.github.io/jest/docs/getting-started.html#babel-integration\"><code>babel-jest</code></a> which comes bundled with Jest in the latest version. Jest can support <a href=\"https://facebook.github.io/jest/docs/configuration.html#transform-object-string-string\">some preprocessors</a>, but somehow cannot support PostCSS as it has asynchronous plugins.\nSo we had to use this proxy called <a href=\"https://github.com/keyanzhang/identity-obj-proxy\">identity-obj-proxy</a> to proxy our styles with the given className.</p>\n<p>An alternative would be to try <a href=\"https://github.com/kosamari/web.advent.today/pull/27#discussion_r91408412\">this advice</a> to preprocess all the css for easy consumption.</p>\n<p>For example for JSX,</p>\n<p><code>&#x3C;div className={styles['button-class']}>Click&#x3C;/div></code></p>\n<p>the below snapshot is generated,</p>\n<p><code>&#x3C;div className='button-class'>Click&#x3C;/div></code></p>\n<p>It does not allow you to test for true styles, only classNames. But, its a tradeoff we have made.</p>\n<p><strong>Can I calculate coverage?</strong></p>\n<p>I'm glad you asked the question! Coverage stats are inbuilt within Jest. No configuration is required. <code>jest --coverage</code> does it.\nThe downside is that it considerably slows down your test runs. Hence we don't keep it on during development. There are also really cool features like coverage thresholds. You can learn this by watching this excellent video on <a href=\"https://egghead.io/lessons/javascript-track-project-code-coverage-with-jest\">Egghead.io by @kentcdodds</a>.</p>\n<h2>Conclusion</h2>\n<p>Its been a couple of weeks since we started using <code>Jest</code>. Code Coverage is slowly growing within the team. However we have configured our PR builds to fail if existing tests fail, that includes snapshots. In the future, we plan to have coverage thresholds too!</p>\n<p>PS - Thanks to <a href=\"https://twitter.com/kosamari\">@kosamari</a> for the encouragement, <a href=\"https://twitter.com/saha_varsha\">@saha_varsha</a> for actually battle testing the above scripts, <a href=\"https://twitter.com/cpojer\">@cpojer</a> for the review and active involvement and <a href=\"https://twitter.com/rahulcs\">@rahulcs</a> for the patient review!</p>",
id:"/Users/pkodmad/Workspace/pkodmad-site/posts/2016-12-08-notes-on-jest.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2016-12-08",path:"/blog/notes-on-jest",title:"Notes on Jest",tags:["react","testing","js"]}}],tagName:"react,testing,js"}}}});
//# sourceMappingURL=path---tags-react-testing-js-92613fb167641c849949.js.map