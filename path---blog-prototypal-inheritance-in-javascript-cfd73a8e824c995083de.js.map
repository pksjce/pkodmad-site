{"version":3,"sources":["webpack:///path---blog-prototypal-inheritance-in-javascript-cfd73a8e824c995083de.js","webpack:///./.cache/json/blog-prototypal-inheritance-in-javascript.json"],"names":["webpackJsonp","356","module","exports","data","markdownRemark","html","frontmatter","date","path","title","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,+mKAAm1JC,aAAkTC,KAAA,oBAAAC,KAAA,6CAAAC,MAAA,0CAAgIC","file":"path---blog-prototypal-inheritance-in-javascript-cfd73a8e824c995083de.js","sourcesContent":["webpackJsonp([30612591328884],{\n\n/***/ 356:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>Javascript has prototypal inheritance. </p>\\n<p>It is one of the few mainstream languages to have this kind of a method to inherit.  </p>\\n<h3>What is prototyping?</h3>\\n<p>Prototyping means to copy the base for creation and then extend the base to the desired features. Then what is classical inheritance? It is to have a fixed frame for an object in the form of a class. This class is duplicated into an object form. For objects with more features, one must first extend the class and then create objects out of the extended class.<br>\\nIn a language where prototypal inheritance is practiced, it generally encourages changing the object properties during run time and <strong>we know for sure this happens in Javascript</strong><br>\\nThis also means that Objects in Javascript are mutable.</p>\\n<p>So to be clear<br>\\nClassical Inheritance ---> <strong>define classes and create an instance of these classes</strong>\\nPrototypal Inheritance ---> <strong>define objects and create new objects from old objects</strong></p>\\n<h4>Code Reuse</h4>\\n<p>In a classical language, it is very clear how code reuse happens. A class is used multiple times to create instances. By extending a class, we make sure the instances of the extended class have the properties of the parent class.<br>\\nIn a prototypal language, it is a bit hazy as to how the child object gets to use the properties defined in the parent. Usually, the language provides a construct/default property on the object to connect it to its parent. This is called <strong>delegation</strong>.  </p>\\n<p>In Javascript specifically, one is allowed to create Objects ex-nihilio(out of nothing). When this is done, such an object is internally prototyped from a universal object call <code>Object</code>. This base object consists of some basic functions such as <code>toString()</code><br>\\nNow how is delegation practiced in javascript? A property called <code>prototype</code> is given to each of the object(except the object literals). This provides the option to chain objects in a heirarchy.\\nLets write some code to demonstrate this.  </p>\\n<p>{%highlight javascript%}\\nvar myObj = function(){\\nthis.a = 1;\\n};\\nconsole.log(myObj.prototype);\\n// Object {}</p>\\n<pre><code>var myChild = function(){\\n    this.b = 2;\\n};\\nconsole.log(myChild.prototype);\\n// Object {}\\n\\nmyChild.prototype = new myObj()\\nconsole.log(myChild.prototype);\\n// myObj {a: 1}\\n\\nvar aa = new myChild()\\nconsole.log(aa.b)\\n// 2\\nconsole.log(aa.a)\\n// 1\\n</code></pre>\\n<p>{%endhighlight%}</p>\\n<p>This is the basic working of the prototype object.<br>\\nLets look deeper.  </p>\\n<p>{%highlight javascript%}\\n//Continuing the above example..\\nvar obj = new myObj();\\nconsole.log(obj.a)\\n// 1\\nconsole.log(myChild.prototype.a)\\n// 1\\nmyChild.prototype.a = 4;\\nconsole.log(aa.a)\\n// 4\\n//But lets check this\\nconsole.log(obj.a)\\n// 1\\n{%endhighlight%}\\nThis seems like correct behaviour. You dont want the child to be able to upset the parent.  </p>\\n<p>{%highlight javascript%}\\nconsole.log(myChild.prototype.b);\\n//undefined\\nconsole.log(aa.b)\\n// 2\\nmyChild.prototype.b = 5\\nconsole.log(aa.b)\\n// 2\\nmyChild.prototype.c = 6\\nconsole.log(aa.c)\\n// 6\\n{%endhighlight%}</p>\\n<p>This shows that the value in the object always overrides the value in the prototype object. Thus the priority of a variable decreases as we go up the prototype chain.</p>\\n<p><strong>The idea of the prototype is that in the above example, all instances of <code>myChild</code> reuse the prototype object<code>myObj</code>. This means that new instance of <code>myObj</code> is not created. All instances of <code>myChild</code> will share one instance of <code>myObj</code></strong></p>\\n<p>{%highlight javascript%}\\n//Continuing on above example\\nvar bb = new myChild();\\nconsole.log(bb.a)\\n// 4\\nmyChild.prototype.a = 2\\nconsole.log(aa.a)\\n// 2\\nconsole.log(bb.a)\\n// 2\\n{%endhighlight%}</p>\\n<h4>Creating a new Object from another Object.</h4>\\n<p>The newer browsers allow us to use <code>Object.create(anotherObj)</code> to create objects while inheriting from another object. For eg\\n{%highlight javascript%}\\nvar Shirt = Object.create({});\\n// sets prototype to Object.\\nvar TShirt = Object.create(Shirt);</p>\\n<pre><code>//In older IE browsers, polyfill\\nObject.create = function(parent){\\n    function child(){};\\n    child.prototype = parent;\\n    return new child();\\n}\\n</code></pre>\\n<p>{%endhighlight%}</p>\\n<h4>What is the constructor?</h4>\\n<p>Lets consider this -\\n{%highlight javascript%}\\nvar FantasyAnimal = function(){};\\nconsole.log(FantasyAnimal.constructor);\\n//function Function() { [native code] }\\nconsole.log(FantasyAnimal.prototype);\\n//Object {}\\nconsole.log(FantasyAnimal.prototype.constructor);\\n//function(){}</p>\\n<pre><code>function Animal(){};\\nconsole.log(Animal.prototype);\\n//Animal {}\\nconsole.log(Animal.prototype.constructor);\\n//function Animal(){}\\n</code></pre>\\n<p>{%endhighlight%}</p>\\n<h3>Summary</h3>\\n<ul>\\n<li>Javascript reuses code by Delegation of the prototype to all children.</li>\\n<li>Change in prototype affects already created children.</li>\\n<li>Children can always override parents properties.</li>\\n<li>Set the constructor to know your roots!</li>\\n</ul>\",\"frontmatter\":{\"date\":\"February 05, 2014\",\"path\":\"/blog/prototypal-inheritance-in-javascript\",\"title\":\"Prototypal Inheritance in Javascript\"}}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---blog-prototypal-inheritance-in-javascript-cfd73a8e824c995083de.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>Javascript has prototypal inheritance. </p>\\n<p>It is one of the few mainstream languages to have this kind of a method to inherit.  </p>\\n<h3>What is prototyping?</h3>\\n<p>Prototyping means to copy the base for creation and then extend the base to the desired features. Then what is classical inheritance? It is to have a fixed frame for an object in the form of a class. This class is duplicated into an object form. For objects with more features, one must first extend the class and then create objects out of the extended class.<br>\\nIn a language where prototypal inheritance is practiced, it generally encourages changing the object properties during run time and <strong>we know for sure this happens in Javascript</strong><br>\\nThis also means that Objects in Javascript are mutable.</p>\\n<p>So to be clear<br>\\nClassical Inheritance ---> <strong>define classes and create an instance of these classes</strong>\\nPrototypal Inheritance ---> <strong>define objects and create new objects from old objects</strong></p>\\n<h4>Code Reuse</h4>\\n<p>In a classical language, it is very clear how code reuse happens. A class is used multiple times to create instances. By extending a class, we make sure the instances of the extended class have the properties of the parent class.<br>\\nIn a prototypal language, it is a bit hazy as to how the child object gets to use the properties defined in the parent. Usually, the language provides a construct/default property on the object to connect it to its parent. This is called <strong>delegation</strong>.  </p>\\n<p>In Javascript specifically, one is allowed to create Objects ex-nihilio(out of nothing). When this is done, such an object is internally prototyped from a universal object call <code>Object</code>. This base object consists of some basic functions such as <code>toString()</code><br>\\nNow how is delegation practiced in javascript? A property called <code>prototype</code> is given to each of the object(except the object literals). This provides the option to chain objects in a heirarchy.\\nLets write some code to demonstrate this.  </p>\\n<p>{%highlight javascript%}\\nvar myObj = function(){\\nthis.a = 1;\\n};\\nconsole.log(myObj.prototype);\\n// Object {}</p>\\n<pre><code>var myChild = function(){\\n    this.b = 2;\\n};\\nconsole.log(myChild.prototype);\\n// Object {}\\n\\nmyChild.prototype = new myObj()\\nconsole.log(myChild.prototype);\\n// myObj {a: 1}\\n\\nvar aa = new myChild()\\nconsole.log(aa.b)\\n// 2\\nconsole.log(aa.a)\\n// 1\\n</code></pre>\\n<p>{%endhighlight%}</p>\\n<p>This is the basic working of the prototype object.<br>\\nLets look deeper.  </p>\\n<p>{%highlight javascript%}\\n//Continuing the above example..\\nvar obj = new myObj();\\nconsole.log(obj.a)\\n// 1\\nconsole.log(myChild.prototype.a)\\n// 1\\nmyChild.prototype.a = 4;\\nconsole.log(aa.a)\\n// 4\\n//But lets check this\\nconsole.log(obj.a)\\n// 1\\n{%endhighlight%}\\nThis seems like correct behaviour. You dont want the child to be able to upset the parent.  </p>\\n<p>{%highlight javascript%}\\nconsole.log(myChild.prototype.b);\\n//undefined\\nconsole.log(aa.b)\\n// 2\\nmyChild.prototype.b = 5\\nconsole.log(aa.b)\\n// 2\\nmyChild.prototype.c = 6\\nconsole.log(aa.c)\\n// 6\\n{%endhighlight%}</p>\\n<p>This shows that the value in the object always overrides the value in the prototype object. Thus the priority of a variable decreases as we go up the prototype chain.</p>\\n<p><strong>The idea of the prototype is that in the above example, all instances of <code>myChild</code> reuse the prototype object<code>myObj</code>. This means that new instance of <code>myObj</code> is not created. All instances of <code>myChild</code> will share one instance of <code>myObj</code></strong></p>\\n<p>{%highlight javascript%}\\n//Continuing on above example\\nvar bb = new myChild();\\nconsole.log(bb.a)\\n// 4\\nmyChild.prototype.a = 2\\nconsole.log(aa.a)\\n// 2\\nconsole.log(bb.a)\\n// 2\\n{%endhighlight%}</p>\\n<h4>Creating a new Object from another Object.</h4>\\n<p>The newer browsers allow us to use <code>Object.create(anotherObj)</code> to create objects while inheriting from another object. For eg\\n{%highlight javascript%}\\nvar Shirt = Object.create({});\\n// sets prototype to Object.\\nvar TShirt = Object.create(Shirt);</p>\\n<pre><code>//In older IE browsers, polyfill\\nObject.create = function(parent){\\n    function child(){};\\n    child.prototype = parent;\\n    return new child();\\n}\\n</code></pre>\\n<p>{%endhighlight%}</p>\\n<h4>What is the constructor?</h4>\\n<p>Lets consider this -\\n{%highlight javascript%}\\nvar FantasyAnimal = function(){};\\nconsole.log(FantasyAnimal.constructor);\\n//function Function() { [native code] }\\nconsole.log(FantasyAnimal.prototype);\\n//Object {}\\nconsole.log(FantasyAnimal.prototype.constructor);\\n//function(){}</p>\\n<pre><code>function Animal(){};\\nconsole.log(Animal.prototype);\\n//Animal {}\\nconsole.log(Animal.prototype.constructor);\\n//function Animal(){}\\n</code></pre>\\n<p>{%endhighlight%}</p>\\n<h3>Summary</h3>\\n<ul>\\n<li>Javascript reuses code by Delegation of the prototype to all children.</li>\\n<li>Change in prototype affects already created children.</li>\\n<li>Children can always override parents properties.</li>\\n<li>Set the constructor to know your roots!</li>\\n</ul>\",\"frontmatter\":{\"date\":\"February 05, 2014\",\"path\":\"/blog/prototypal-inheritance-in-javascript\",\"title\":\"Prototypal Inheritance in Javascript\"}}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/blog-prototypal-inheritance-in-javascript.json\n// module id = 356\n// module chunks = 30612591328884"],"sourceRoot":""}